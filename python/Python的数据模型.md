# 0x00 数据模型(Data model) {#data_model}

## 0x10 对象、值和类型(Objects, values and types)

在Python中，对象(Objects)是对数据的抽象。所有的数据在Python中都是通过对象或者对象间的关系来表示的。

Python中所有的对象都一个一个身份(identity)，一个类型(type)和一个值(value)。一个对象的身份在对象创建以后就不能被改变，可以认为一个对象的身份就是这个对象在内存中的地址值。Python的**is**操作符用于比较两个对象的身份是否是一样的。内建函数**id()**返回一个整数表示的对象的身份。

**CPython 实现细节：** 对于CPython，**id(x)**的值就是x存储的地址。

一个对象的类型决定了这个对象支持的操作，同时也决定了这个对象可能的值。内建函数**type()**返回一个对象的类型。和对象的身份一样，对象的类型也是不可以修改的。

一些对象的值可以被修改。对象的值可以被修改的对象被称为可变对象(mutable)；对象的值在对象被创建以后不能被改变的，被称为不可变对象(immutable)。(一个不可变容器中包含了一个可变对象的引用，则这个可变对象可以被修改，但是这个容器还是被认为是不可变的，因为这个容器中包含的对象是不能被改变的。所以，不可变类型在并不是说它只能包含不可变的值。)一个对象的可变性取决于它的类型：数字，字符串和元组是不可变的，而字典和列表是可变的。

对象不能被显式销毁。然而，当一些对象不被引用的时候，它们可能会被垃圾回收机制回收。一些实现允许延迟垃圾回收或者完全的忽略。这些都是垃圾回收机制的实现问题，只要保证那些能被引用的对象不被垃圾回收机制回收。

**CPython 实现细节：** CPython 当前采用引用计数的方式和定时(delayed)检测循环链接的垃圾(可选的)，当一个对象不被引用的时候，就会很快被垃圾回收机制回收，但是不保证会回收掉循环引用的对象。当一个对象不被引用的时候，不能依赖它会立即终结的假设。(所以，我们需要在文件访问完后立即调用close()函数)。

注意，在使用跟踪或者调试工具的时候，可能会保持引用那些本来会被垃圾回收掉的对象，使得这些对象仍旧存活。并且，在**try ... except**语句可能会导致那些本来会被回收掉的对象仍旧存活。

一些对象包含了对外部资源的引用，不如打开的文件或窗口。这些被引用的资源，在对象被垃圾回收以后被自动释放，但是，垃圾回收机制并不能保证一定会回收这些对象，所以，为了保证这些外部资源可以被释放掉，这些对象提供了一些显式的方式释放这些外部资源，通过使用**close()**方法来显式释放资源。通过 **try ... finally**字句和**with**语句提供了方便的方式来保证资源的释放。

一些对象包含了对其他对象的引用，这些对象被称为容器(containers)。比如元组，字典和列表就是容器。容器中的值是对象的引用，在大多数情况下，提到容器的值，我们一般指的是容器中的引用指向值，而不是这个值的引用(身份)。然而，当我们讨论容器的可变性的时候，我们讨论容器的值，指的是容器中的对象的引用。所以，对于一个元组，它是不可变类型的，但是如果一个元组中包含了一个列表，那么这个列表的值是可以修改的，但是这个列表的引用(身份)是一直不变的，那么，无论这个列表中的值怎么变化，对于包含这个列表的元组来说，它的包含的值(也就是这个列表的身份)是不会改变的，所以我们说元组的不可变类型。

类型几乎影响了对象的所有行为。即使是对象的身份，在一些情况下，也收到类型的影响。对于不可变类型，操作返回的新的值可能会引用同一个已经存在具有相同类型和值的对象，但是，对于可变类型，这是不可能的。比如：**a = 1; b = 1**，则a 和 b可能引用了同一个对象，这个依赖于实现。但是对于**c = []; d = []**，c和d保证是不会引用同一个对象的。

## 0x20 标准类型体系(The standard type hierachy)

以下部分是Python的内建类型。扩展模块(采用C，Java或其他语言编写的模块，依赖于特定的实现)可以定义额外的类型。Python可能在未来添加其他的类型到当前的类型体系中。

### 0x21 None

None类型只有一个值。并且只有一个对象拥有这个值。这个对象通过内建名字**None**来访问。这个对象用于缺失值的情况下。当一个函数没有显式指定返回值的时候，则这个函数将返回None。这个对象的真值是false。

### 0x22 NotImplemented

NotImplemented类型只有一个值。并且只有一个对象拥有这个值。这个对象通过内建的名字**NotImplemented**访问。数值方法和比较方法在对应的操作数没有对应的操作的时候应该返回这个对象。这个对象的真值是true。

### 0x23 Ellipsis

这个类型的对象只有一个值。并且只有一个对象拥有这个值。这个对象可以通过一个省略号**...**来访问，或者通过内建对象**Ellipsis**来访问。这个对象的真值是true。

### 0x24 numbers.Number

这个类型的对象是通过数值字面值来创建，并且作为数值操作或数值内建函数的返回值返回。数值对象是不可变的。一旦创建了数值对象，那么这个对象的值就不能被改变了。Python的数值基本和数学上的数值是一致的，但是对于数值的表示收到计算机的限制。

Python提供了整数(integers)，浮点数(floating)，和复数(complex numbers)。

#### 0x241 numbers.Integral

这个类型是对数学上整数的表示（正数和负数）。

这里有两种类型的整数：

整数(int)
:   整数类型表示了一个没有限定范围的数值，可以表示的长度受限于计算机的内存大小。整数支持移位和掩码操作等位操作。

布尔类型(bool)
:   这个类型表示True和False。布尔类型是整数类型的子集，布尔类型的值True和False相当于整数的0和1。并且，在大多数上下文中，如果需要将布尔值转换为字符串的时候，会对应装换为"True"和"False"。

#### 0x242 numbers.Real(float)

这个类型表示了机器级别的双精度浮点数。Python不支持单精度浮点数，Python为了简化语言，并不对单精度进行支持。

#### 0x243 numbers.Complex(complex)

这个类型表示复数，复数是两个双精度浮点数的组成的浮点数对。复数的实部和虚部可以通过复数对象z的z.real和z.imag获得。

### 0x25 序列(sequence)

序列用于表示有限的有序集合，通过非负的整数进行索引。内建函数**len()**用于返回序列中包含的对象的个数。序列的索引是从0开始的。可以通过下标操作符来获得指定索引的对象。

序列支持分片操作：**a[i:j]**表示选择序列中下标为k的对象，其中k满足i <= k < j。

一些序列支持额外的分片操作，可以指定步进长度，如**a[i:j:k]**，这用于选择所有下标为x = i + n * k，其中x满足 i <= x < j。

序列依据是不是可变的，可以分成如下几类：

#### 0x251 不可变序列(Immutable sequences)

不可变序列表示，当一个序列被创建以后，就不能被修改了。（但是序列中包含的对象是可以是可变的）。

* 字符串(Strings)	
一个字符串是一个包含了Unicode码的序列。字符串中所有的Unicode码值在U+0000 - U+10FFFF之间。Python不支持char类型；但是可以用一个字符长度的字符串代表char类型。内建函数**ord()**用于将一个字符串转换为对应的Unicode码值。内建函数**chr()**用于将一个范围在0-10FFFF之间的Unicode码值转换为对应的字符串。str类型的内建函数**str.encode()**通过给定的编码方式将一个str类型的对象转换为byte类型对象。而**str.decode()**用于做相反的操作。

* 元组(Tuples)	    
Python中的元组可以包含任何对象。一个以上的对象组成的元组通过逗号分隔。只有一个对象的元组，可以通过在对象后面添加逗号来表示只有一个对象的元组。（用一个括号包裹一个对象，并不会创建一个单个对象的元组，因为括号被用来对表达式进行分组，而不是创建元组）。一个空的元组可以用一个空的括号来表示。

* 字节序列(Bytes)	
一个字节序列对象是一个不可变的数组。字节序列中的对象是一个8位的字节，代表整数0-255。字节序列字面值(b'abc')和内建函数**bytes()**可以被用于构建字节序列对象。字节序列对象可以通过**decode()**方法解码成字符串。

#### 0x252 可变序列(Mutable sequences)

可变序列在创建以后可以被修改。下标操作符和分片符号可以被赋值，并且可以被del语句操作。

* 列表(List)	    
列表中的对象可以是任何Python对象。列表的形式是通过一个方括号将一系列通过逗号分隔的对象包裹起来。

* 字节数组(Byte Arrays)	    
一个直接数组对象是一个可变对象。可以通过内建函数**bytearray()**来创建字节数组对象。除了字节数组是可变的对象以外，所有的操作接口都是和不可变的字节序列一样的。

额外的**array**模块和**collections**模块提供了第三方的可变序列的实现。

### 0x26 集合类型(Set types)

集合类型用于表示无序的，有限的序列，其中序列中的对象是唯一的。集合对象不支持下标操作，但是集合对象可以被迭代。内建函数**len()**返回集合中对象的数目。集合的主要用处是进行快速的成员关系测试，从一个序列中删除重复的对象，并且在数学上支持集合运算。

对于集合中的对象，具有和字典的键值一样的不可变性规则。注意，对于数值类型的对象，遵循数值对象的比较规则：如果两个数值比较的结果是相等的，那么表示这两个对象是相等的（比如1和1.0），只有其中任何一个对象可以包含在集合中。

* Sets	    
Sets类型表示一个可变的集合类型。可以通过内建函数set()来创建。可以通过诸如add()等成员方法进行修改。

* Frozen sets	    
Frozen sets用于表示不可变集合。可以通过内建函数frozenset()来创建。一个frozenset对象是不可变的，并且是可哈希的。它可以作为其他集合中的对象，也可以作为字典的键值。

## 0x27 映射类型(Mappings)

映射类型用于表示有限的集合，集合中的对象可以被任意的索引集合索引。下标操作a[k]表示从映射类型对象a中通过索引k取出对应的对象。a[k]可以用于作为赋值操作的左值，也可以被del语句作用。内建函数**len()**返回映射对象中包含的对象的数目。

* Dictionaries      
字典用于表示有限的集合，集合中的元素差不多可以被任何值索引。只有那些包含了列表或者字典或者其他可变类型对象的值不能作为字典的键值外，其他类型都可以作为字典的键值。这是为了高效的计算字典的键值，需要键值的哈希值是一个常数。数值类型作为字典的键值，遵循一般的数值类型对比规则：如果两个数值比较的结果相等，那么这两个键值将在字典中索引相同的对象。

字典类型是可变的，可以通过使用**{...}**方式创建字典。

扩展模块 dbm.ndbm和dbm.gnu以及collections提供了额外的映射类型的实现。

## 0x28 可调用类型(Callable types)

可调用对象可以通过函数操作符进行调用。

### 0x281 用户自定义函数

用户自定义函数对象通过一个函数定义被创建。在函数被调用的时候，需要有和定义时的参数列表数目一样的参数被传递进去。

函数对象的特殊属性：

| 属性 | 描述 |W/R  |
|:----:|:-----|:---:|
| \_\_doc\_\_ | 函数对象的文档字符串，如果没有定义，则为None，不能被子类继承 | Writable |
| \_\_name\_\_ | 函数名 | Writable |
| \_\_qualname\_\_ | 函数的qualified 名字 | Writable |
| \_\_module\_\_ | 函数所在的模块的名字，如果没有，则为None | Writable |
| \_\_defaults\_\_ | 一个包含了默认参数值的元组，如果没有默认参数，则为None | Writable |
| \_\_code\_\_ | 函数对象编译以后的代码对象 | Writable |
| \_\_globals\_\_ | 一个字典的引用，字典中包含了函数的全局变量——全局名字空间是函数所在的模块的名字空间 | Readonly |
| \_\_dict\_\_ | 函数对象的名字空间 | Writable |
| \_\_closure\_\_ | 函数的自由变量组成的元组，如果没有自由变量，则为None | Writable |
| \_\_annotations\_\_ | 一个包含了参数注解的字典，键值是参数名，对于return注解，键值为'return'|Writable|
| \_\_kwdefaults\_\_ | 一个包含了默认的关键字属性的字典 | Writable |


函数对象也支持设置和获取任意的属性，通用的属性操作符(.)可以用于设置或获取这些属性。注意，Python当前的是实现只支持用户自定义函数的属性。内建函数的属性可能会在未来被支持。

### 0x282 实例方法

实例方法的只读属性包括：

* **\_\_self\_\_** 是类的实例对象
* **\_\_func\_\_** 是函数对象
* **\_\_doc\_\_** 是方法的文档字符串(值和**\_\_func\_\_.\_\_doc\_\_**一样)
* **\_\_name\_\_**是方法的名字(值和**\_\_func\_\_.\_\_name\_\_**一样)
* **\_\_module\_\_**是方法所在的模块的名字，如果没有则为None。

方法可以访问它当前对应的函数对象的任何属性。

在获得一个类的属性的时候（可能是通过类的实例对象来获取），如果这个类属性是一个用户自定义函数对象或者是一个类方法对象，则会创建一个用户自定义方法。

当通过类的实例对象来调用这个类中定义的用户自定义函数，则会创建一个实例方法，实例方法的**\_\_self\_\_**属性的值就是这个实例对象，这个时候，这个方法对象就被认为是绑定了的，这个方法对象的**\_\_func\_\_**属性的值就是原来那个用户自定义函数对象。

当通过其他的类或实例的方法对象来创建用户自定义方法对象，则新的方法对象的**\_\_func\_\_**属性是原来那个方法对象的**\_\_func\_\_**属性。

当通过类或实例的类方法对象来创建实例方法对象，方法对象的**\_\_self\_\_**属性的值是这个类对象，而**\_\_func\_\_**属性是这个类对象对应的函数对象。

```python

>>> class C(object):
    def method(self):
        pass

    
>>> class CC(object):
    @classmethod
    def cls_method(cls):
        pass

>>> C.method.__self__
Traceback (most recent call last):
  File "<pyshell#52>", line 1, in <module>
    C.method.__self__
AttributeError: 'function' object has no attribute '__self__'

>>> c = C()
>>> c.method.__self__
<__main__.C object at 0x02E76EB0>

# 通过类对象CC的类方法cls_method来创建方法对象    
>>> C.method = CC.cls_method
>>> C.method.__self__
<class '__main__.CC'>   #这个方法对象的__self__属性是类对象CC

>>> c = C()
>>> c.method.__self__
<class '__main__.CC'>   #这个方法对象的__self__属性是类对象CC

```

当一个实例方法对象被调用的时候，这个方法对象的**\_\_func\_\_**属性中的函数对象被调用，把存储在**\_\_self\_\_**属性中的这个类实例对象作为第一个参数被传递到这个函数对象中。例如：如果类对象C有一个函数对象f()，x是类C的实例对象，则当调用x.f(1)的时候，相当于是调用了C.f(x, 1)。

当一个实例方法对象是继承自一个类方法对象，则类实例被存储在这个方法对象的**\_\_self\_\_**属性中，所以x.f(1)和C.f(1)相当于是f(C,1)。

注意：从函数对象到实例方法对象的转换是发生在每次调用这个实例的方法的时候，在一些情况下，通过将实例对象的方法属性赋值给一个局部变量，可以在以后需要调用这个方法的时候直接调用这个局部变量，这可以起到优化程序的作用。这种类型的转换只是发生在获得用户自定义函数对象上，其他对象在获得的时候是不会进行转换的。注意：作为类实例对象的属性出现的用户自定义函数对象并不会被绑定为方法对象，只有是作为类对象的属性出现的用户自定义函数对象才会在调用的时候被转为绑定方法。

### 0x283 生成器函数

一个函数或者方法中使用了**yield**语句，则这个函数或方法被称为生成器函数。生成器函数在被调用的时候，会返回一个可以执行函数体的迭代器，调用迭代器的**iterator.\_\_next\_\_()**方法将会使函数体知晓直到通过yield语句产生一个结果。当函数执行了return语句，或者到达了最后，则抛出一个**StopIteration**异常，表明迭代器已经到达了最后。

### 0x284 内建函数

内建函数是对C实现的函数的封装，内建函数的参数类型和数目取决于C实现的函数。内建函数的只读属性包括：

* **\_\_doc\_\_**是函数的文档字符串，如果没有，则为None
* **\_\_name\_\_**是函数的名字
* **\_\_self\_\_**的值为None
* **\_\_module\_\_**是函数所在模块的名字，如果没有，则为None。

### 0x285 内建方法

内建方法是对内建函数的伪装(disguise)，传递到C实现的函数的对象作为一个隐式的额外参数被传递进去。比如内建方法alist.append()，其中的alist就是一个列表对象。内建方法的只读属性**\_\_self\_\_**的值是传递进去的对象，在这里就是alist对象。

### 0x286 类对象

类对象是可调用的，类对象的行为类似于创建实例的工厂，可以通过重载类的**\_\_new\_\_()**方法来修改对象的创建过程。调用类的时候，会将参数传递到**\_\_new\_\_()**方法中，一般情况下，会进一步调用**\_\_init\_\_()**方法来初始化新的实例对象。

### 0x287 类实例

实例对象可以通过重载**\_\_call\_\_()**方法来实现函数调用功能。

##  0x29 模块

模块是Python中代码的基本组织单元，模块通过import机制被创建，通过**import**语句或者调用类似于**importlib.import_module()**方法和内建的**\_\_import()\_\_()**方法。一个模块对象有一个通过字典创建的名字空间（定义在模块中的函数对象的**\_\_globals\_\_**属性引用的就是这个字典对象）。引用模块属性的时候会查看这个字典，如：m.x就相当于m.\_\_dict\_\_["x"]。模块对象没有包含初始化这个模块的代码对象（因为一旦模块被初始化以后，这些对象就没有用了）。

对模块的属性赋值会更新名字空间字典\_\_dict\_\_，如：m.x = 1 相当于是m.\_\_dict\_\_["x"] = 1。

模块的特殊只读属性包括：**\_\_dict\_\_**是通过字典类型创建的模块名字空间。

**CPython 实现细节：**由于CPython对模块字典的特殊的清除方式，当模块离开作用域的时候，即使模块的名字空间字典**\_\_dict\_\_**仍旧被别的对象引用，也会被清除。所以为了避免这种情况，在直接访问这个字典对象的时候，需要将字典对象拷贝一份或者保证这个字典对象在使用的时候是在外围作用域中。

模块对象中已经定义的属性包括：

* \_\_name\_\_属性是模块的名字
* \_\_doc\_\_属性是模块的文档字符串，如果不存在，则为None
* \_\_file\_\_如果模块是从文件中加载的，则这个属性是被加载的模块所在文件的路径，对于那些主要类型的模块，比如通过静态链接到解释器的C模块，这些模块的\_\_file\_\_属性可能会丢失。从动态链接库中加载的扩展模块，这些模块的\_\_file\_\_属性是动态链接库的路径。

## 0x2A 自定义类类型

自定义的类类型是通过类定义创建的。一个类有一个通过字典实现的名字空间。对类属性的引用会通过查看这个字典对象来获得。比如：C.x会转换为C.\_\_dict\_\_["x"]（存在一些其他的钩子来实现不同的属性查找方式）。如果属性的名字没有找到，则会在当前类的父类中继续查找。对于父类的查找顺序遵循C3-MRO（method resolution order），C3-MRO是一种即使是在具有多条来自公共的祖先的继承路径的继承结构中，也可以正确工作的机制。关于C3-MRO的详细信息，可以查看python的2.3版本中的[mro相关文档](https://www.python.org/download/releases/2.3/mro/)

当一个类的属性引用会产生一个类方法对象的时候，这个属性会被转化为一个实例方法对象，这个实例方法对象的**\_\_self\_\_**属性的值是这个类的类对象（比如类C）。当这个属性的引用会产生一个静态方法对象的时候，这个属性的引用会被转化为一个通过一个静态方法对象包裹的对象。Python的[描述符](https://docs.python.org/3/reference/datamodel.html#descriptors)提供了另外一种区别于通过类的名字空间字典对象\_\_dict\_\_来获取属性行为的方式。

对类属性进行赋值会更新类的名字空间字典对象，但不会更新父类的名字空间字典。

通过调用一个类对象会产生这个类的实例对象。

类对象的特殊属性：

* **\_\_name\_\_**是类的名字
* **\_\_module\_\_**是类所在的模块的名字
* **\_\_dict\_\_**是类的名字空间字典
* **\_\_bases\_\_**是包含了当前类的所有父类的元组，如果没有父类，则可以为空，
  元组中的顺序是这些父类在基类列表中出现的顺序
* **\_\_doc\_\_**是类的文档字符串，如果没有定义，则为None

## 0x2B 类实例

一个类实例是通过调用类对象获得的。一个类实例有一个通过字典对象**\_\_dict\_\_**实现的名字空间。实例对象的属性访问遵循如下的步骤：

* 首先，会对字典对象**\_\_dict\_\_**进行检查，查看访问的属性是否在这个字典对象中
* 如果在字典对象中没有找到这个属性，则会对这个实例对象的类对象进行搜索
    * 如果这个类属性是一个用户自定义函数对象，则这个函数对象会被转换为一个实例方法对象，这个实例方法对象的\_\_self\_\_属性是的值这个实例对象。
    * 如果属性是静态方法对象或类方法对象，也会被转化为实例的方法对象
* 如果在类属性中也没有找到，如果这个对象的类由一个\_\_getattr\_\_()方法，则会调用这个方法。

实例对象的属性的赋值和删除都会对实例对象的字典进行更新，而不会对这个实例所属的类对象的名字空间进行修改。如果类实现了\_\_setattr\_\_()或\_\_delattr()\_\_方法，则会通过这两个方法间接得对实例的名字空间字典对象进行更新。

实例对象的特殊属性：

* **\_\_dict\_\_**是实例的名字空间字典
* **\_\_class\_\_**是实例所属的类对象

## 0x2C I/O对象(文件对象)

一个文件对象表示一个打开的文件。可以有很多方式打开一个文件对象，内建函数**open()**可以用于创建一个文件对象，其他的包括**os.open()**，**os.fdopen()**，**makefile()**等都可以创建文件对象。

sys.stdin，sys.stdout，sys.stderr这三个对象用于初始化对应于解释器的标准输入，标准输出，和标准出错的文件对象。这三个对象都是通过文本模式实现的，并且这三个对象都实现了相同的接口**io.TextIOBase**抽象类

## 0x2D 内部类型

Python有一些内部类型用于解释器向用户暴露一些接口。

### 0x2D1 代码对象

代码对象用于表示已经被编译过的可执行Python字节码。代码对象和函数对象的区别是，函数对象包含了一个显式的指向全局作用域(这个函数被定义的模块的名字空间)的引用，而代码对象并没有包含上下文，并且在函数对象中包含了默认参数的值，而代码对象中并没有包含这些默认参数。和函数对象不同，代码对象是不可变的，并且不包含任何指向（直接或间接）可变对象的引用。

代码对象的只读属性包括：

* co_name表示函数的名字
* co_argcount表示位置参数的数目，包括包含了默认参数值的位置参数
* co_nlocals表示函数的局部变量的数目，局部变量包括函数的参数
* co_varnames表示局部变量的名字组成的元组，函数的参数出现在前面
* co_cellvars表示被内嵌函数引用的局部变量的名字组成的元组
* co_freevars表示函数的自由变量的名字组成的元组
* co_code表示字符串形式的字节码指令
* co_consts表示字节码需要使用的字面值
* co_names表示字节码需要使用的名字组成的列表
* co_filename表示编译出这个字节码的源文件的文件名
* co_firstlineno表示函数的第一行的行号
* co_lnotab表示通过字符串编码的从字节码偏移量到行号的映射（具体实现细节依赖于解释器）
* co_stacksize表示需要的栈大小，这个栈大小包括局部变量
* co_flags是一个整数，对解释器的一系列标记进行编码

对于co_flags属性，有以下一些值：

* 0x02 表示当这个函数是一个生成器的时候，设置这个值
* 0x04 表示当采用*arguments方式的参数的时候，会设置这个值
* 0x08 表示当采用\*\*keywords方式的参数的时候，会设置这个值

对于Future特性声明中(from \_\_future\_\_ import division)，co_flags属性用于表明代码对象是否在编译的时候包含了特殊的特性：

* 0x2000 表示函数在编译的时候包含了在future中的division特性
* 0x10和0x1000 表示使用的是早期版本的Python

其他的co_flags的值被保护用于内部使用。

如果一个代码对象表示的是一个函数，则co_consts属性的值的第一项是这个函数的文档字符串，如果这个函数没有文档字符串，则这一项的值为None。

### 0x2D2 帧对象(Frame objects)

帧(Frame)对象代表了正在执行的栈帧。帧对象一般出现在跟踪(traceback)对象中。

帧对象的只读属性包括：

* f_back表示前一个栈帧对象，即当前栈帧的调用者，如果当前栈帧是在栈低，则这个属性的值为None
* f_code表示当前正在栈帧中执行的代码对象
* f_locals表示当前局部变量的名字空间字典
* f_globals表示当前全局变量的名字空间字典
* f_builtins表示内建名字
* f_lasti给出了最后执行的指令（这是一个对代码对象的字节码字符串的索引）

帧对象的可写属性包括：

* f_trace，如果值为None，则表示这个栈帧是在最开始的时候创建的（用于debugger）
* f_lineno，栈帧中的当前的行号，通过在跟踪函数中改写这个属性的值可以跳转到给定的行（只对当前栈帧下面的栈帧有用）。通过改写这个属性，一个调试器可以用于实现跳转命令。

帧对象支持一个clear方法

frame.**clear()**
:   这个方法清理栈帧中所有指向局部变量的引用。如果栈帧是属于一个生成器的，则这个生成器会被终止。这可以帮助清理当前栈帧对象的引用循环（比如：当捕捉到一个异常，并把这个traceback存储起来的时候）。当前栈帧如果正在执行，则调用这个方法会抛出**RuntimeError**异常。

### 0x2D3 Traceback对象

Traceback对象表示对一个异常的栈跟踪。当出现一个异常的时候，会创建一个trackback对象。当搜索一个异常处理器的时候，会展开当前正在执行的栈帧，在每一个已经展开的层次上会在当前traceback前插入一个traceback对象。当进入了一个异常处理器，栈跟踪对当前程序就变成可用了。这个栈跟踪可以通过sys.exc_info()返回的元组中的第三个值来获得。当一个程序不包含合适的异常处理器的时候，这个栈跟踪会以合理的格式被输出到标准错误输出中。如果解释器是交互的，也可以通过sys.last_traceback获得。

特殊的只读属性：

* tb_next 表示栈跟踪的下一层（朝着异常产生的栈帧），如果当前没有下一层，则值为None。
* tb_frame 指向一个当前层次上正在执行的栈帧
* tb_lineno 异常产生时所在的行号
* tb_lasti 指出最后执行的指令的索引

在traceback中，如果在try语句中没有匹配的异常处理器或者finally语句，行号和最后执行的指令的索引可能会不一样。

### 0x2D4 分片对象(Slice objects)

分片对象用于为\_\_getitem\_\_()方法表示分片。内建函数**slice()**也会创建分片对象。

分片对象的特殊属性：

* start 表示分片的下边界，如果没有则为None
* stop 表示分片的上边界，如果没有则为None
* step 表示步进值，如果没有则为None

这些属性可以包含任何类型。

分片对象支持一个**indices**方法：

slice.**indices**(self, length)
:   这个方法接收一个整数的length参数，计算分片对象相关的信息。这个方法返回一个包含3个整数的元组，分别对应了分片的开始下标，结束下标和步进值。指数丢失或者越界都会以普通的分片方式处理。

### 0x2D5 静态方法对象

静态方法对象提供了一种打破将一个函数对象转换为一个方法对象的方式。一个静态方法对象是一个可以包裹任何对象的包装器，一般会作用于一个用户自定义方法对象。当通过类或者类实例来访问一个静态方法对象，会返回一个经过包裹过的对象，而不会进行其他的转换。静态方法对象不能递归调用，即使被包裹的对象可以被递归调用。静态方法对象可以通过内建的**staticmethod()**函数来创建。

### 0x2D6 类方法对象

类方法对象和静态方法对象类似，类方法对象也是一个包装器。类方法对象用于修改通过类或类实例来访问对象的方式。类方法对象可以通过内建函数**classmethod()**创建。

## 0x30 Python的特殊方法

一个类可以调用一些实现了的具有特殊的名字的方法来实现一些操作（比如数值操作或分片操作，下标操作等）。

Python支持操作符重载。比如，如果一个类实现了**\_\_getitem\_\_()**方法，则这个类的实例就支持下标操作，x[i]和**type(x).\_\_getitem\_\_(x, i)**是等价的。当实例没有实现所执行的操作对应的特殊方法的时候，会抛出**AttributeError**或**TypeError**异常。

当需要创建一个类来模拟一个内建类型的时候，只能在一定程度上模拟内建类型。比如，对于序列类型，可以模拟获取和添加元素，但是在进行分片的时候，行为可能会不同。

## 0x31 基本定制(Basic customization)

object.**\_\_new\_\_**(cls[,...])
:   调用这个方法创建并返回类cls的实例。
    **\_\_new\_\_()**方法是一个静态方法，这个方法的第一个参数是需要创建实例所属的类对象，剩下的其他参数和创建实例的时候传递给类对象的参数一致。**\_\_new\_\_()**方法应该返回一个新的实例对象（一般情况下是类cls的实例）。

    创建一个类的实例的典型方式是通过调用父类的**\_\_new\_\_()**方法，通过合适的参数调用**super(currentclass, cls).\_\_new\_\_(cls[,...])**，获得创建的实例对象，然后进行必要的定制以后返回这个实例对象。

    如果**\_\_new\_\_()**方法返回一个实例对象，则会调用实例的**\_\_init\_\_(self[,...])**方法。参数self是这个新的实例对象，剩下的参数和传递给**\_\_new\_\_()**的参数中剩下的参数是一致的。

    如果**\_\_new\_\_()**没有返回一个实例对象，则这个实例对象的**\_\_init\_\_()**方法将不会被调用。

    **\_\_new\_\_()**方法的主要目的是用于继承不可变类型（比如int，str或tuple）来定制实例创建过程。也通常用于在元类中被重写来定制类的创建过程。


object.**\_\_init\_\_**(self[,...])
:   当新创建的实例从**\_\_new\_\_()**方法返回后，会调用这个方法来初始化这个实例对象，然后才会完成类实例的创建过程，然会给调用这个类对象的用户。
    传递给这个方法的参数和调用类对象时传递的参数是一致的。如果一个基类也拥有一个**\_\_init\_\_()**方法，则必须在子类的**\_\_init\_\_()**中显式调用父类的**\_\_init\_\_()**方法，保证正确地初始化这个实例的父类部分。
    因为**\_\_new\_\_()**和**\_\_init\_\_()**一起工作来构造一个对象（**\_\_new\_\_()**方法创建对象，而**\_\_init\_\_()**负责对创建的这个对象进行定制）。
    **\_\_init\_\_()**方法应该不会有返回值，如果这个方法有返回值，则在运行时将会抛出一个TypeError异常。


object.**\_\_del\_\_**(self)
:   当实例将要被销毁的时候会调用这个方法。这个方法也被称为析构器。
    如果基类定义了一个**\_\_del\_\_()**方法，那么，在子类的**\_\_del\_\_()**方法中需要显式调用父类的**\_\_del\_\_()**方法，以保证可以正确的释放父类的部分。
    注意，如果给将要析构的对象创建一个新的引用，则可以延迟释放这个资源。当这个新的引用被删除以后，这个对象才会被真正得析构。当解释器退出得时候，不能保证那些对象会调用**\_\_del\_\_()**方法。

    **注意：**
    del x并不保证会调用x.\_\_del\_\_()，del语句执行的时候会将x引用的对象的引用数减1，然后当这个对象的引用数为0的时候，才会执行这个对象的\_\_del\_\_()方法。
    在一些情况下，可能会导致不能将对象的引用计数减为0：当在两个对象间出现循环引用的时候（比如：双向链表或者是一棵树中节点的结构包含父节点和子节点的指针），
    这种情况下，可以通过显式打破循环引用来解决；一个指向存在于一个抛出了异常的函数的栈帧中的对象的引用（traceback对象被存储在sys.exc_info()[2]中，保证栈帧一直存在），
    这种情况下，可以通过释放对不再使用的traceback对象的引用来解决；
    在交互模式下，一个指向存在于抛出了未处理的异常的栈帧中的引用（traceback存储在sys.last_traceback中保证栈帧是存活的），这可以通过将一个None对象赋值给last_traceback中来解决。
    对于循环引用，当循环gc被启用的时候，可以对循环引用进行判断和解决（默认并不开启）。有关gc的内容，可以查看[这里](https://docs.python.org/3/library/gc.html#module-gc)

    **警告:**
    由于在执行\_\_del\_\_()方法的时候处于危险(precarious)的情况(circumstances)中，所以在执行\_\_del\_\_()方法的过程中抛出的异常会被忽略，
    但是会在标准错误输出sys.stderr中输出警告信息。当\_\_del\_\_()方法被调用以处理模块被删除的时候（比如：当程序执行完毕退出），
    \_\_del\_\_()方法引用的其他全局变量可能已经被删除或者正在被删除（比如：import机制正在被关闭）。
    出于这个原因，\_\_del\_\_()方法应该对外部的不变部分尽可能少的维护。从Python 1.5开始，Python保证以一个下划线开头的全局变量会从模块中先于其他全局对象被删除；
    如果没有其他的引用指向这些全局变量，但是这些带下划线的全局对象仍旧存在则可以帮助确定导入进来的模块在调用\_\_del\_\_()方法的时候仍旧存在。

object.**\_\_repr\_\_**(self)
:   这个特殊方法被内建的repr()函数调用，用于计算出一个"官方"的表示一个对象的字符串。如果可能，返回值应该看起来像一个有效的Python表达式，用于重新构建一个对象。如果不可能，则返回一个类似于<...some useful description...>形式的字符串。返回值必须是一个字符串对象如果一个类定义了\_\_repr\_\_()，但是没有定义\_\_str\_\_()，则会用\_\_repr\_\_()代替\_\_str\_\_()。

    这个方法一般用在debug中，所以这个方法的返回的信息应该是明确和有代表性的。

object.**\_\_str\_\_**(self)
:   被内建函数str(object)调用，或者被内建的format()和print()函数调用，用于输出有用的信息，或者是被格式化的数据。返回值必须是一个字符串对象。

    这个方法和object.\_\_repr\_\_()的区别是：\_\_str\_\_()返回的不必是一个有效的python表达式，只需要是一个可以表示信息的字符串对象。

    内建的object对象的默认实现是调用object.\_\_repr\_\_()方法。

object.**\_\_byptes\_\_**(self)
:   通过内建函数bytes()调用，用于返回一个byte-string表示的对象，方法应该返回一个bytes对象。

object.**\_\_format\_\_**(self, format_spec)
:   通过内建函数format()调用（对str.format()的扩展）返回一个格式化了的用于表示一个对象的字符串。参数 *format_spec* 是一个包含了格式化选项的字符串。对这个包含格式化选项的字符串的解析依赖于对这个方法的实现，然而，大多数类都会将对解析操作代理给别的内建类型，或者采用相似的格式化语法。

    对格式化选项的描述，可以详细查看[这里](https://docs.python.org/3/library/string.html#formatspec)
    这个方法的返回值必须是一个字符串对象。
    在Python 3.4中，\_\_format\_\_方法如果接收了一个任意的非空的字符串，则会抛出一个**TypeError**异常。

object.**\_\_lt\_\_**(self, other)；object.**\_\_le\_\_**(self, other)；object.**\_\_eq\_\_**(self, other)；object.**\_\_ne\_\_**(self, other)；object.**\_\_gt\_\_**(self, other)；object.**\_\_ge\_\_**(self, other)
:   这些方法被称为"富比较"（rich comparison）方法。比较操作符和这些方法的对应关系如下：x < y 会执行x.\_\_lt\_\_(y)，x <= y 会执行x.\_\_le\_\_(y)，x == y 会执行 x.\_\_eq\_\_(y)，x != y 会执行 x.\_\_ne\_\_(y)，x > y 会执行x.\_\_gt\_\_(y)，x >= y 会执行 x.\_\_ge\_\_(y)。

    如果对象没有实现对应给定参数的方法，一个富比较方法可能会返回一个单例的NotImplement对象。作为惯例，这些方法调用成功会返回一个True或False。然而，这些对象实际上可以返回任何类型的对象，所以如果一个比较操作是用于一个布尔上下文中，Python将会调用bool()内建函数作用在返回值上，用于确定结果是不是一个布尔值。
    这些比较操作符之间没有隐式的关系，x == y为真并不意味着x != y为假。一般情况下，当定义了\_\_eq\_\_()，应该也定义\_\_ne\_\_()，这可以使得操作的行为是我们期望的。

object.**\_\_bool\_\_**(self)
:   被内建函数bool()调用进行真值测试。方法应该返回False或True。如果这个方法没有定义，则\_\_len\_\_()会被调用，如果\_\_len\_\_()方法被定义了，则如果这个方法的返回值是非0的，则值为True，否则为False。如果既没有定义\_\_bool\_\_()也没有定义\_\_len\_\_()，则所有的实例对象都被认为是真的。

object.**\_\_hash\_\_**(self)
:   被内建函数hash()调用，作用于可哈希集合中的成员。可哈希集合包括：set，frozenset和dict。\_\_hash\_\_()的返回值应该是一个整数。
    
    注意：
    hash()函数会对对象自定义的\_\_hash\_\_()方法进行截断，截断的长度为Py_ssize_t。这个值在64位机上构建的值为8个字节，在32位机上构建的是4字节。如果一个对象的\_\_hash\_\_()方法必须在不同架构的平台上操作，则需要对所有支持的架构进行检查。可以通过**python -c "import sys; print(sys.hash_info.width)"**来获得。
    
    如果一个类没有定义\_\_eq\_\_()方法，则这个类不应该定义\_\_hash\_\_()方法；如果定义了\_\_eq\_\_()，但是没有定义\_\_hash\_\_()，这个类的实例将不能作为可哈希集合的成员。
    
    如果一个类定义了可变对象，并且实现了\_\_eq\_\_()方法，则这个类不能定义\_\_hash\_\_()方法，因为可哈希集合的实现要求键值是不可变类型的。
    
    用户自定义类默认实现了\_\_eq\_\_()和\_\_hash\_\_()方法。这使得每个不同的对象都是不相等的，并且对象的\_\_hash\_\_()会返回一个合适的值，使得当x == y的时候，x is y 并且 hash(x) == hash(y)。
    
    一个类如果覆盖了\_\_eq\_\_()方法，但是没有定义\_\_hash\_\_()方法，则\_\_hash\_\_()方法隐式为None。如果对象的\_\_hash\_\_()方法为None，试图获得这个对象的哈希值的时候会抛出TypeError异常。
    
    如果一个类覆盖了\_\_eq\_\_()方法，并且希望从父类中继承\_\_hash\_\_()方法，则需要显式赋值：\_\_hash\_\_ = <ParentClass>.\_\_hash\_\_。
    
    如果一个类不重写\_\_eq\_\_()以达到不支持hash的目的，这个类应该设置\_\_hash\_\_的值为None。

## 0x32 自定义属性访问

Python提供了一系列的方法用于自定义属性的访问。

object.**\_\_getattr\_\_**(self, name)
:   当属性没有被找到的时候会调用这个方法（属性并不是实例对象的属性也不在实例对象所属的类层次中）。 *name* 参数是属性的名字。这个方法需要返回一个属性，或者抛出一个AttributeError异常。
    
    注意，如果属性属性通过一般的属性查找机制被找到，则这个方法将不会被调用。这么做的目的，一方面是考虑到性能问题，另一方面是\_\_getattr\_\_()可能不能访问实例对象的其他属性。注意，至少对于实例属性，可以通过这个方法来做到对属性访问的完全控制。

object.**\_\_getattribute\_\_**(self, name)
:   当访问实例对象的时候会无条件地调用这个方法来进行访问。如果类定义了\_\_getattr\_\_()方法，则这个方法将不会被调用，除非在\_\_getattribute\_\_()中显式调用这个方法，或者在\_\_getattribute\_\_()中抛出了一个AttributeError异常。\_\_getattribute\_\_()方法需要返回一个值或者抛出一个AttributeError异常。为了防止在方法中出现无限递归，对这个方法的实现应该总是调用基类的\_\_getattribute\_\_()方法来访问需要的任何属性。
    **注意**：\_\_getattribute\_\_()方法在查找特殊函数的时候可能会被绕过，当通过Python的语法或者内建的函数来隐式调用的调用特殊方法的时候。

object.**\_\_setattr\_\_**(self, name, value)
:   当属性赋值的时候会被调用。这个方法会代替一般的属性设置机制（一般情况下会将属性的值存储在实例的名字空间字典中）。 *name* 参数是属性的名字， *value* 参数是赋值的值。
    如果通过\_\_setattr\_\_()方法进行赋值，应该在方法中调用基类的\_\_setattr\_\_()方法。

object.**\_\_delattr\_\_**(self, name)
:   删除实例对象的属性，这个方法只有在del语句作用在这个属性上有意义的情况下才实现。

object.**\_\_dir\_\_**(self)
:   当内建函数dir()调用的时候被调用，这个方法返回一个序列。dir()内建函数将这个方法返回的序列转换为一个列表，并进行排序。

## 0x33 描述符（descriptor）

### 0x331 实现描述符

以下的几个方法只会用于一种类，当这种类（这种类被称为描述符类）的实例出现在一个拥有者的类中（描述符必须出现在拥有者类的名字空间字典中，或者拥有者类的父类的名字空间字典中）。

下面提到的属性，这些属性的名字是拥有者类的名字空间字典\_\_dict\_\_中的键值。

object.**\_\_get\_\_**(self, instance, owner)
:   调用这个方法获得拥有者类的属性或者这个类的实例的属性。 *owner* 参数是拥有者类， *instance* 参数是属性访问时绑定的那个实例，如果是通过拥有者类来访问的，则这个参数的值为None。这个方法应该返回一个属性的值，或者抛出一个AttributeError异常。

object.**\_\_set\_\_**(self, instance, owner)
:   调用这个方法设置实例 *instance* 的属性值。

object.**\_\_delete\_\_**(self, instance)
:   调用这个方法删除实例 *instance* 的属性。


### 0x332 调用描述符

通俗的说，一个描述符就是对象中一个绑定了特定行为的属性，对这个属性的访问和修改都被描述符协议（\_\_set\_\_(), \_\_get\_\_(), \_\_delete\_\_()）重写。如果一个类中定义了这些方法中的任何一个，则这个类的实例就被称为是一个描述符。

对象访问和修改的默认的行为是通过访问和修改对象的名字空间字典来实现的。对于实例a，a.x会首先查看a.__dict__['x']，如果没有找到，则查看type(a).__dict__['x']，然后是type(a)的基类（但不包括元类），直到找到为止。

如果查找的属性是一个描述符，则Python的默认查找机制可能会被描述符协议代替。使用描述符协议进行属性访问的时机依赖于描述符中实现的方法类型和调用的方式。

描述符被调用的开始位置是进行了绑定访问a.x，对于参数传递到描述符的途径，依赖于实例a：

直接调用
:   最简单和最通用的调用方式是在代码中直接调用描述符的方法:x.\_\_get\_\_(a)。

实例绑定
:   如果属性被绑定到一个实例，则a.x被转换为这样的调用方式：type(a).\_\_dict\_\_['x'].\_\_get\_\_(a, type(a))。

类绑定
:   如果属性被绑定到一个类，则A.x被转换为这样的调用方式：A.\_\_dict\_\_['x'].\_\_get\_\_(None, A)。

基类绑定
:   super(B, obj).m()会搜索obj.\_\_class\_\_.\_\_mro\_\_，查找B的直接父类A，然后调用A.\_\_dict\_\_['m'].\_\_get\_\_(obj, obj.\_\_class\_\_)

对于实例绑定，描述符调用的优先级依赖于描述符中定义了哪些方法。一个描述符可以任意组合\_\_get\_\_()，\_\_set\_\_()和\_\_delete\_\_()方法。如果描述符没有定义\_\_get\_\_()方法，则当这个描述符赋值给类属性的时候，当通过类的实例来访问这个属性的时候，会返回这个描述符对象，除非这个实例的名字空间字典中包含了同名的属性，则返回这个属性的值。如果描述符定义了\_\_set\_\_()或者\_\_delete\_\_()方法，则这个描述符被称为数据描述符，如果这两个方法都没有定义，则这个描述符被称为非数据描述符。一般情况下，数据描述符都定义了\_\_get\_\_()和\_\_set\_\_()方法，而非数据描述符只定义了\_\_get\_\_()方法。数据描述符如果定义了\_\_get\_\_()和\_\_set\_\_()方法，则会覆盖在实例字典中的定义，相反，对于非数据描述符，可以被实例属性覆盖。

Python方法（包括staticmethod()和classmethod()）是作为非数据描述符实现的，因此，实例可以重新定义或覆盖这些方法。这允许同一个类的不同的实例可以有不同的行为。

## 0x34 \_\_slots\_\_

默认情况下，类的实例对象有一个存储属性的字典对象\_\_dict\_\_。当实例拥有很少的属性的时候，这会导致空间的浪费。特别是当申请了很对这样的对象的时候，空间浪费问题会变得很严峻。

Python的这种默认存储属性的方式可以通过在类定义中定义\_\_slots\_\_类属性来更改。\_\_slots\_\_类属性声明了一个由实例可以包含的属性的名字组成的序列，在每个实例中保留足够的空间来存储这些属性的值。由于\_\_dict\_\_对象并不会在每个实例中创建，所以可以节约空间。

object.**\_\_slots\_\_**
:   这个类属性可以被一个字符串，或者一个迭代器，或者是一个由字符串组成的序列进行赋值，这些字符串表示可以在类的实例中使用的属性名。\_\_slots\_\_属性会在创建的实例中给声明的属性名保留足够的空间，并且阻止为每个实例自动创建\_\_dict\_\_属性和\_\_weakref\_\_属性。

### 0x341 使用__slots__的注意点

* 当继承的父类中没有定义\_\_slots\_\_类属性，则子类的\_\_dict\_\_属性仍旧是可以被访问的，所以在子类中定义\_\_slots\_\_类属性是没有意义的。

* 如果实例没有\_\_dict\_\_属性，则不能对不在\_\_slots\_\_类属性中的属性赋值。试图对不在\_\_slots\_\_中的变量赋值会抛出一个AttributeError异常。如果希望可以对一个实例添加一个新的属性，则可以将\_\_dict\_\_属性名'\_\_dict\_\_'添加到\_\_slots\_\_类属性中。

* 如果实例没有\_\_weakref\_\_属性，则实例不支持对实例的weak引用。如果实例需要weak引用，则添加'\_\_weakref\_\_'属性名到\_\_slots\_\_类属性中。

* \_\_slots\_\_类属性是在类级别被实现的，\_\_slots\_\_属性会在类级别为每一个声明了的变量创建描述符，这就使得不能为在\_\_slots\_\_中定义的属性通过设置同名的类属性的值来为实例创建默认的属性值。

* \_\_slots\_\_声明的作用范围限定在定义这个类属性的类中，所以在子类中如果没有定义\_\_slots\_\_属性，则在子类的实例中仍旧会创建\_\_dict\_\_属性。

* 如果一个类定义了一个插槽(slot)，而这个插槽也定义在基类中，那么当实例对象的属性是基类定义的，则这个属性不能被访问。（除非从基类中把描述符取过来）

* 非空的\_\_slots\_\_类属性在继承自可变长度的内建类型(比如：int，bytes和tuple)的类中时，是无效的。

* 任何非空的字符串迭代器可以赋值给\_\_slots\_\_属性。映射类型也可以用于给\_\_slots\_\_属性赋值。

* \_\_class\_\_的赋值操作只有在两个类具有相同的\_\_slots\_\_时才有效。
